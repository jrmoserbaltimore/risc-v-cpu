\chapter{Pipeline}

\section{Skid Buffer}
I built the Kerberos skid buffer based on excellent explanations at the ZipCPU blog \footcite{ZipCPU.Pipeline}.  \prettyref{fig:pipeline-skid-buffer-fsm} shows the state machine for the skid buffer.  \prettyref{tab:skid-buffer-handshake-state} shows information about each state; as noted on the ZipCPU blog, \inlinecode{$In.Busy = FullBuffer$}.

\afterpage{

\begin{table}[ht]
    \caption{table}{Handshake States} % title of Table
    \centering % used for centering table
    \begin{tabular}{c c c c} % centered columns (4 columns)
        \hline\hline
        State & FullBuffer & Out.Strobe & DataOut \\ [0.5ex] % inserts table

        \hline
        Passthrough & 0 & In.Strobe & Din \\
        Buffer & 1 & In.Strobe & Din \\
        Flush & 0 & 1 & Buffer \\ [1ex]
        \hline
    \end{tabular}
    \label{tab:skid-buffer-handshake-state}
\end{table}

    % Pipeline FSM
\begin{figure}
    \begin{center}
        \begin{tikzpicture}[->,>=latex,auto]
    %    \tikzstyle{every node}+=[inner sep=0pt]

        \node[initial,accepting,state] (Pass) {$Pass$};
        \node[state] (Buf) [right of=Pass, node distance=8cm] {$Buffer$};
        \node[accepting,state] (Flush) [below left of=Buf, node distance=6cm] {$Flush$};

        \path (Pass)  edge [loop above] node {!In.Strobe $||$ !Out.Busy} (Pass)
                      edge node {In.Strobe \&\& Out.Busy} (Buf)
              (Buf)   edge [loop above] node {Out.Busy} (Buf)
                      edge [bend left] node {!Out.Busy} (Flush) % Bend right
              (Flush) edge [bend left] node {In.Strobe \&\& Out.Busy} (Buf)
                      edge [bend left] node {!In.Strobe $||$ !Out.Busy} (Pass);
        \end{tikzpicture}
        \caption{Handshake State Machine}
    \end{center}
    \label{fig:pipeline-skid-buffer-fsm}
\end{figure}
}

Pipeline stages signal $Busy$ whenever they are in the $Run$ or $Wait$ states.  A circuit is in the $Run$ state while it is processing, and in the $Wait$ state when it has data sitting on its output but the next stage remains $Busy$.  When the circuit is neither strobing to the next circuit nor processing, it becomes $Idle$, and is not $Busy$ even if the next stage becomes $Busy$. This produces four states:  Idle, Run, Wait, and Finish, shown in \prettyref{tab:pipeline-exec-circuit-state}.

The circuit passes its data on in the Finish state, and is idle on the next iteration; however, the busy signal is \inlinecode{Processing || (DataReady \&\& PipeIn.Busy)}, and so signals \inlinecode{!Busy} on the cycle on which it delivers data.  The \inlinecode{SkidBuffer} itself must accept the data and, besides, is \inlinecode{!Busy} when its buffer is empty and will not magically become busy.

\afterpage{
\begin{table}[ht]
    \caption{Execution Circuit Handshake States} % title of Table
    \centering % used for centering table
    \begin{tabular}{c c c c c} % centered columns (4 columns)
        \hline\hline
        State & Processing & DataReady & PipeOut.Busy & PipeIn.Busy \\ [0.5ex] % inserts table

        \hline
        Idle & 0 & 0 & X & 0 \\
        Run & 1 & 0 & X & 1 \\
        Wait & 0 & 1 & 1 & 1 \\
        Finished & 0 & 1 & 0 & 0 \\ [1ex]
        \hline
    \end{tabular}
    \label{tab:pipeline-exec-circuit-state}
\end{table}
\begin{figure}
    \begin{center}
        \begin{tikzpicture}[->,>=latex,auto]
            %    \tikzstyle{every node}+=[inner sep=0pt]

            \node[initial,accepting,state] (Idle) {Idle};
            \node[state] (Run) [right of=Idle, node distance=8cm] {Run};
            \node[state] (Wait) [below of=Run, node distance=5cm] {Wait};
            \node[accepting,state] (Finish) [below of=Idle, node distance=5cm] {$Flush$};

            \path (Idle)   edge [loop above] node {!PipeIn.Strobe} (Pass)
            edge node {PipeIn.Strobe} (Run)
            (Run)    edge [loop right] node {!DataReady} (Run)
            edge node {DataReady} (Wait)
            (Wait)   edge [loop right] node {PipeOut.Busy} (Wait)
            edge node {!PipeOut.Busy} (Finish)
            (Finish) edge node {PipeIn.Strobe} (Run)
            edge node {!PipeIn.Strobe} (Idle);
        \end{tikzpicture}
        \captionof{figure}{Execution Circuit Handshake State Machine}
    \end{center}
\end{figure}
}

\section{Fetch}

The \inlinecode{Fetch} stage obtains new instructions and passes them through the pipeline.  It can pass forward large amounts of data—one or several cache lines—containing several instructions, along with the value of \inlinecode{pc} after a branch.  \inlinecode{Fetch} always retrieves and passes along a chunk of instruction stream aligned to its chunk size.

\section{Pre-Decode}

\inlinecode{Pre-Decode} prepares the instruction stream for \inlinecode{Decode}.  It receives instruction stream from \inlinecode{Fetch} one chunk at a time, and tracks \inlinecode{pc} to identify the current address.

\inlinecode{Pre-Decode} converts RISC-V Compressed instructions (RVC) to normal RISC-V instructions.  RVC includes all opcodes with the two least-significant bits not equal to \inlinecode{11}, so \inlinecode{Decode} can ignore these two bits.  This allows cheap handling of \inlinecode{C.JAL} and \inlinecode{C.JALR}:  RVC passes the lower two bits of the opcode forward as-is, and the \inlinecode{Branch} circuit adds 2 rather than 4 to \inlinecode{pc} when these bits are not \inlinecode{11}.

\inlinecode{Pre-Decode} separates each quadrant of RVC into an independent combinational circuit and selects the output via a mux.

Whether expanded from RVC or passed forward verbatim, \inlinecode{Pre-Decode} assembles a single 32-bit instruction with its context information for \inlinecode{Decode}.

\section{Decode}

\inlinecode{Decode} converts instructions to an internal bundle of signals indicating the operation, width, signed or unsigned nature, and instruction layout type.  Like \inlinecode{Pre-Decode}, groups of logically-similar instructions execute as independent combinational circuits and raise a signal to indicate an identified instruction.

Often a single opcode maps to only one or two formats, and the \inlinecode{funct3} and \inlinecode{funct7} fields indicate data width, sign, or modes such as shift-right or subtract, so these circuits are quite compact in gate logic.  A 5-LUT can decode an opcode, and often a 5-LUT or 6-LUT can look up the remaining information—often one bit in the opcode, three from \inlinecode{funct3}, and one from \inlinecode{funct7}.  This minimizes the logic used on FPGAs.

\section{Order}

\section{Load}

\section{Execute}

Small numbers above and below the execute operation indicate the number of cycles and the latency per execution unit.  For example, if the execution stage contains two dividers, the latency can be one cycle rather than however long it takes for the divider to complete.

The \inlinecode{Branch} and \inlinecode{Load/Store} operations use the ALU for simultaneous addition and comparison.  A speculative adder will occasionally run for two cycles, in which case so will \inlinecode{Load/Store}.  Tight loops use backwards branches and suffer a significant performance loss if the addition requires an extra cycle; therefor the ALU supplies two comparators, and the \inlinecode{Branch} unit caches the address of the prior interpreted branch instruction.  \inlinecode{Branch} jumps to the the cached target address if the branch condition and prior branch instruction match, avoiding the adder for all but the first iteration of a tight loop.

\section{Memory Access and Cache}

\inlinecode{Memory Access} also forwards register loads back through the pipeline.  Both \inlinecode{MemoryAccess} and \inlinecode{Fetch} connect directly to VC-DSR L1 cache.